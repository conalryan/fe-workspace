import { html, LitElement, PropertyValues } from "lit";
import { property, customElement } from "lit/decorators.js";

/**
 * Mixins - "is-a" composition
 *
 *  A mixin is an abstract subclass; i.e. a subclass definition that may be applied 
 * to different superclasses to create a related family of modified classes.
 *  - Gilad Bracha and William Cook, Mixin-based Inheritance
 * 
 * The real, and only, difference between a mixin and normal subclass is that a normal subclass has a fixed superclass, 
 * while a mixin definition doesn't yet have a superclass. Only the mixin applications have their own superclasses.
 * 
 * Class mixins are a pattern for sharing code between classes using standard JavaScript.
 * As opposed to "has-a" composition patterns like reactive controllers,
 * where a class can own a controller to add behavior, mixins implement "is-a" composition,
 * where the mixin causes the class itself to be an instance of the behavior being shared.
 * 
 * Mixins can be thought of as "subclass factories" that override the class 
 * they are applied to and return a subclass, extended with the behavior in the mixin. 
 * 
 * Mixins may not declare private/protected properties
 * however, you can use ES2020 private fields
 */

/**
 * Mixins in Typescript
 * 
 * You should constrain the superClass argument to the type of class you expect users to extend, if any. 
 * This can be accomplished using a generic Constructor helper type as shown below: 
 */
type Constructor<T = {}> = new (...args: any[]) => T;

const LoggingMixin = <T extends Constructor<LitElement>>(superClass: T) =>
  class extends superClass {
    constructor(...args: any[]) {
      super(...args);
      console.log(`${this.localName} was created`);
    }

    connectedCallback() {
      super.connectedCallback();
      console.log(`${this.localName} was connected`);
    }

    updated(changedProperties: PropertyValues) {
      super.updated?.(changedProperties);
      console.log(`${this.localName} was updated`);
    }
  }

@customElement("uses-logging-mixin")
export class UsesLoggingMixin extends LoggingMixin(LitElement) {
  render() {
    return html`<div>Uses Logging Mixin</div>`;
  }
}

/**
 * Typeing the Subclass
 * 
 * TypeScript has basic support for inferring the return type of the subclass generated by the mixin,
 * However,the inferred class must not contain members with private or protected access modifiers.
 * 
 * LitElement itself does have private and protected members, by default TypeScript will error with "Property '...' 
 * of exported class expression may not be private or protected." when returning a class that extends LitElement.
 * 
 * When a mixin does not add new public/protected api
 * 
 * If your mixin only overrides LitElement methods or properties and does not add any new API of its own, 
 * you can simply cast the generated class to the super class type T that was passed in:
 */
export const NoNewMembersMixin = <T extends Constructor<LitElement>>(superClass: T) => {
    class MyMixinClass extends superClass {
      connectedCallback() {
        super.connectedCallback();
        this.doSomethingPrivate();
      }
  
      private doSomethingPrivate() {
        /* does not need to be part of the interface */
      }
    };
    // Cast return type to the superClass type passed in
    return MyMixinClass as T;
  }

/**
 * When a mixin adds new public/protected api
 * 
 * Define the interface for the mixin separately from the implementation, 
 * and cast the return type as the intersection of your mixin interface and the super class type:
 */
export declare class NewMembersMixinInterface {
  highlight: boolean;
  protected renderHighlight(): unknown;  
}
  

export const NewMembersMixin = <T extends Constructor<LitElement>>(superClass: T) => {
  class NewMembersMixinClass extends superClass {
    @property() highlight = false;
    
    protected renderHighlight() {
        /* ... */
    }  
  };
  // Cast return type to your mixin's interface intersected with the superClass type
  return NewMembersMixinClass as unknown as Constructor<NewMembersMixinInterface> & T;
}

// Here are some of the most common mixins used with Lit elements:
// UpdatingElement Mixin
// This is actually built into LitElement already
// Provides the core updating lifecycle and property system
// Handles reactive property updates and rendering

// ThemeableMixin
//    const ThemeableMixin = (superClass) => 
//      class extends superClass {
//        static styles = [...(superClass.styles || []), css`
//          /* theme styles */
//        `];
//      }
// Adds theming capabilities
// Commonly used for applying consistent styling across components

// LocalizeMixin
// const LocalizeMixin = (superClass) => 
//     class extends superClass {
//       @property() locale = 'en';
      
//       translate(key: string) {
//         // Translation logic
//       }
//     }
// Adds internationalization capabilities
// Handles translations and locale-specific formatting

// RippleMixin
// const RippleMixin = (superClass) =>
//     class extends superClass {
//       firstUpdated() {
//         super.firstUpdated();
//         this.addEventListener('click', this._createRipple);
//       }
      
//       _createRipple(e: MouseEvent) {
//         // Ripple effect logic
//       }
//     }
// Adds material design ripple effects
// Common in button and interactive elements

// ValidatableMixin
// const ValidatableMixin = (superClass) =>
//     class extends superClass {
//       @property() invalid = false;
      
//       validate() {
//         // Validation logic
//         return true;
//       }
      
//       checkValidity() {
//         // Check validity logic
//       }
//     }
// Adds form validation capabilities
// Common in form input elements

// RouterMixin
// const RouterMixin = (superClass) =>
//     class extends superClass {
//       @property() route = '';
      
//       _handleNavigation() {
//         // Navigation logic
//       }
//     }
// Adds routing capabilities
// Used in single-page applications

// LoadingMixin
// const LoadingMixin = (superClass) =>
//     class extends superClass {
//       @property() loading = false;
      
//       async performAction() {
//         this.loading = true;
//         try {
//           // Async work
//         } finally {
//           this.loading = false;
//         }
//       }
//     }
// Adds loading state management
// Useful for handling async operations

// Remember when using mixins:
// Always call super methods when overriding lifecycle methods
// Be careful about mixin ordering when using multiple mixins
// Consider using TypeScript for better type safety with mixins
// Avoid deep mixin chains as they can become hard to maintain
// For the best practices:
// - Use mixins for cross-cutting concerns that affect multiple components
// - Prefer composition (controllers) over mixins when possible
// - Document mixin requirements and assumptions clearly
// - Keep mixins focused on a single responsibility
// cr. Would mixins for common inputs make sense e.g. disabled, readonly, etc.?
